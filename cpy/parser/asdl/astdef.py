#!/usr/bin/env python

if __name__ == '__main__':
    import os
    import sys

    thisdir = os.path.dirname(__file__)
    sys.path.insert(0, os.path.realpath(os.path.join(thisdir, '../../../')))
    from cpy.parser.asdl.astdef import ASTDef

    d = ASTDef(open(os.path.join(thisdir, 'Python.asdl')).read())
    open(os.path.join(thisdir, '..', 'ast.py'), 'w').write(d.generate())
    exit(0)


from .asdl_states import states
from ..grammar import Grammar
from collections import OrderedDict
import six


class Type(object):
    def __init__(self, super_type, name, attrs):
        self.super_type = super_type
        self.name = name
        self.attrs = attrs
        if super_type:
            self.attrs += super_type.attrs

    def generate(self, indent='    '):
        super_type = self.super_type and self.super_type.name or 'object'
        yield 'class %s(%s):\n' % (self.name, super_type)
        attrs = [attr.name for attr in self.attrs]
        yield indent + '__slots__ = (%s)\n' % ', '.join(map(repr, attrs))
        if attrs:
            yield '\n'
            yield indent + 'def __init__(self, %s):\n' % ', '.join(attrs)
            for attr in self.attrs:
                yield indent * 2 + 'self.{0} = {0}\n'.format(attr.name)


    def __repr__(self):
        if self.super_type is not None:
            return '<Type %s(%s)>' % (self.name, self.super_type.name)
        return '<Type %s>' % self.name


class Attribute(object):
    def __init__(self, type, name, repeat='1'):
        self.type = type
        self.name = name
        self.repeat = repeat  # 1 + *

    def __repr__(self):
        if self.repeat == '1':
            return '<Attr %s %s>' % (self.type, self.name)
        return '<Attr %s%s %s>' % (self.type, self.repeat, self.name)


class ASTDef(object):
    def __init__(self, asdlsrc):
        grammar = Grammar(states, 'asdl')
        self.tree = grammar.parse(asdlsrc)
        self.build()

    def generate(self):
        buf = six.StringIO()
        buf.write('# generated by cpy/parser/asdl/astdef.py\n')
        for t in self.types.values():
            buf.write('\n\n')
            buf.write(''.join(t.generate()))
        return buf.getvalue()

    def stmt_nodes(self):
        for module in self.tree.entry.subs:
            if module.name == 'module' and module.subs[1].val == 'Python':
                break
        else:
            raise Exception('missing Python module')
        for node in module.subs[2:]:
            if node.name == 'stmt':
                yield node

    def build(self):
        self.types = OrderedDict()
        for node in self.stmt_nodes():
            self.build_stmt(node)

    def build_stmt(self, stmt_node):
        name = stmt_node.subs[0].val
        item_nodes = list(self.item_nodes(stmt_node))
        if len(item_nodes) == 1 and len(item_nodes[0].subs) == 1:
            # tt = (t1 a, t2 b)
            attrs = list(self.attrs(item_nodes[0].subs[0]))
            self.types[name] = Type(None, name, attrs)
            return

        # tt = T1(...) | T2(...) [attributes (...)]
        if len(stmt_node.subs) >= 5 and stmt_node.subs[-2].val == 'attributes':
            attrs = list(self.attrs(stmt_node.subs[-1]))
        else:
            attrs = []
        t = Type(None, name, attrs)
        self.types[name] = t
        for item_node in item_nodes:
            self.build_named_item(t, item_node)

    @staticmethod
    def item_nodes(stmt_node):
        for node in stmt_node.subs[2:]:
            if node.name == 'item':
                yield node

    def build_named_item(self, super_type, item_node):
        name = item_node.subs[0].val
        if len(item_node.subs) == 2:
            attrs = list(self.attrs(item_node.subs[1]))
        else:
            attrs = []
        self.types[name] = Type(super_type, name, attrs)

    def attrs(self, attrs_node):
        for node in attrs_node.subs[1:]:
            if node.name == 'attr':
                yield self.build_attr(node)

    @staticmethod
    def build_attr(attr_node):
        type_name = attr_node.subs[0].val
        if len(attr_node.subs) == 2:
            return Attribute(type_name, attr_node.subs[1].val)
        repeat = attr_node.subs[1].val
        return Attribute(type_name, attr_node.subs[2].val, repeat)
