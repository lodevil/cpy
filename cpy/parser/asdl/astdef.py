#!/usr/bin/env python

if __name__ == '__main__':
    import os
    import sys

    thisdir = os.path.dirname(__file__)
    sys.path.insert(0, os.path.realpath(os.path.join(thisdir, '../../../')))
    from cpy.parser.asdl.astdef import ASTDef

    d = ASTDef(open(os.path.join(thisdir, 'Python.asdl')).read())
    open(os.path.join(thisdir, '..', 'ast.py'), 'w').write(d.generate())
    exit(0)


from .asdl_states import states, symbols
from ..grammar import Grammar
from collections import OrderedDict
import six


class_eq = '''
class Equal(object):
    pass

class NotEqual(object):
    pass


class ASTNode(object):
    def __eq__(self, obj):
        if obj is Equal:
            return True
        for attr in self.__slots__:
            a = getattr(self, attr, NotEqual())
            b = getattr(obj, attr, NotEqual())
            if a is Equal or b is Equal:
                continue
            if a != b:
                return False
        return True
'''


class Type(object):
    def __init__(self, super_type, name, attrs):
        self.super_type = super_type
        self.name = name
        self.attrs = attrs
        self.init_args = attrs[:]
        for i, arg in enumerate(self.attrs):
            if arg.name == self.name:
                self.init_args[i] = '_' + arg.name

    def generate(self, indent='    '):
        super_type = self.super_type and self.super_type.name or 'ASTNode'
        yield 'class %s(%s):\n' % (self.name, super_type)

        attrs = []
        for attr in self.attrs:
            if attr.name == self.name:
                attrs.append((attr.name, '_' + attr.name))
            else:
                attrs.append((attr.name, attr.name))
        if len(attrs) == 1:
            yield indent + '__slots__ = (%s,)\n\n' % repr(attrs[0][0])
        else:
            yield indent + '__slots__ = (%s)\n\n' % ', '.join(
                map(lambda x: repr(x[0]), attrs))
        
        if attrs:
            init = 'def __init__(self, %s, *argv, **kwargv):\n' % ', '.join(
                map(lambda x: x[1], attrs))
            yield indent + init
            for attr in attrs:
                yield indent * 2 + 'self.%s = %s\n' % (attr[0], attr[1])
        else:
            yield indent + 'def __init__(self, *argv, **kwargv):\n'
        upper = 'super(%s, self).__init__(*argv, **kwargv)\n' % self.name
        yield indent * 2 + upper

    def __repr__(self):
        if self.super_type is not None:
            return '<Type %s(%s)>' % (self.name, self.super_type.name)
        return '<Type %s>' % self.name


class Attribute(object):
    def __init__(self, type, name, repeat='1'):
        self.type = type
        self.name = name
        self.repeat = repeat  # 1 + *

    def __repr__(self):
        if self.repeat == '1':
            return '<Attr %s %s>' % (self.type, self.name)
        return '<Attr %s%s %s>' % (self.type, self.repeat, self.name)


class ASTDef(object):
    def __init__(self, asdlsrc):
        grammar = Grammar(symbols, states, 'asdl')
        self.tree = grammar.parse(asdlsrc)
        self.build()

    def generate(self):
        buf = six.StringIO()
        buf.write('# generated by cpy/parser/asdl/astdef.py\n')
        buf.write(class_eq)
        for t in self.types.values():
            buf.write('\n\n')
            buf.write(''.join(t.generate()))
        return buf.getvalue()

    def stmt_nodes(self):
        for module in self.tree.entry.subs:
            if module.type == symbols.module and module.subs[1].val == 'Python':
                break
        else:
            raise Exception('missing Python module')
        for node in module.subs[2:]:
            if node.type == symbols.stmt:
                yield node

    def build(self):
        self.types = OrderedDict()
        for node in self.stmt_nodes():
            self.build_stmt(node)

    def build_stmt(self, stmt_node):
        name = stmt_node.subs[0].val
        item_nodes = list(self.item_nodes(stmt_node))
        if len(item_nodes) == 1 and len(item_nodes[0].subs) == 1:
            # tt = (t1 a, t2 b)
            attrs = list(self.attrs(item_nodes[0].subs[0]))
            self.types[name] = Type(None, name, attrs)
            return

        # tt = T1(...) | T2(...) [attributes (...)]
        if len(stmt_node.subs) >= 5 and stmt_node.subs[-2].val == 'attributes':
            attrs = list(self.attrs(stmt_node.subs[-1]))
        else:
            attrs = []
        t = Type(None, name, attrs)
        self.types[name] = t
        for item_node in item_nodes:
            self.build_named_item(t, item_node)

    @staticmethod
    def item_nodes(stmt_node):
        for node in stmt_node.subs[2:]:
            if node.type == symbols.item:
                yield node

    def build_named_item(self, super_type, item_node):
        name = item_node.subs[0].val
        if len(item_node.subs) == 2:
            attrs = list(self.attrs(item_node.subs[1]))
        else:
            attrs = []
        self.types[name] = Type(super_type, name, attrs)

    def attrs(self, attrs_node):
        for node in attrs_node.subs[1:]:
            if node.type == symbols.attr:
                yield self.build_attr(node)

    @staticmethod
    def build_attr(attr_node):
        type_name = attr_node.subs[0].val
        if len(attr_node.subs) == 2:
            return Attribute(type_name, attr_node.subs[1].val)
        repeat = attr_node.subs[1].val
        return Attribute(type_name, attr_node.subs[2].val, repeat)
